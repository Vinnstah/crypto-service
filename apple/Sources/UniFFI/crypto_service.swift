// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(crypto_serviceFFI)
    import crypto_serviceFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_crypto_service_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_crypto_service_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol GatewayProtocol: AnyObject {
    func getListOfAggCoins(key: String) async throws -> [Coin]
}

open class Gateway:
    GatewayProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_crypto_service_fn_clone_gateway(self.pointer, $0) }
    }

    /**
     * Constructs a new [`GatewayExternalClient`] using a "network antenna" - a type
     * implementing [`FFIOperationExecutor`] on the FFI side (Swift side), e.g.
     * `[Swift]URLSession` which wraps the execution of a network call.
     */
    public convenience init(networkAntenna: NetworkAntenna) {
        let pointer = try! rustCall {
            uniffi_crypto_service_fn_constructor_gateway_new(
                FfiConverterTypeNetworkAntenna.lower(networkAntenna), $0
            )
        }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_crypto_service_fn_free_gateway(pointer, $0) }
    }

    open func getListOfAggCoins(key: String) async throws -> [Coin] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_crypto_service_fn_method_gateway_get_list_of_agg_coins(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(key)
                    )
                },
                pollFunc: ffi_crypto_service_rust_future_poll_rust_buffer,
                completeFunc: ffi_crypto_service_rust_future_complete_rust_buffer,
                freeFunc: ffi_crypto_service_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeCoin.lift,
                errorHandler: FfiConverterTypeFFIBridgeError.lift
            )
    }
}

public struct FfiConverterTypeGateway: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Gateway

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Gateway {
        return Gateway(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Gateway) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Gateway, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeGateway_lift(_ pointer: UnsafeMutableRawPointer) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(pointer)
}

public func FfiConverterTypeGateway_lower(_ value: Gateway) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGateway.lower(value)
}

public protocol NetworkAntenna: AnyObject {
    func makeRequest(request: FfiNetworkingRequest) async throws -> FfiNetworkingResponse
}

open class NetworkAntennaImpl:
    NetworkAntenna
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_crypto_service_fn_clone_networkantenna(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_crypto_service_fn_free_networkantenna(pointer, $0) }
    }

    open func makeRequest(request: FfiNetworkingRequest) async throws -> FfiNetworkingResponse {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_crypto_service_fn_method_networkantenna_make_request(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFFINetworkingRequest.lower(request)
                    )
                },
                pollFunc: ffi_crypto_service_rust_future_poll_rust_buffer,
                completeFunc: ffi_crypto_service_rust_future_complete_rust_buffer,
                freeFunc: ffi_crypto_service_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFFINetworkingResponse.lift,
                errorHandler: FfiConverterTypeFFINetworkingError.lift
            )
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNetworkAntenna {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNetworkAntenna = .init(
        makeRequest: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> FfiNetworkingResponse in
                guard let uniffiObj = try? FfiConverterTypeNetworkAntenna.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.makeRequest(
                    request: FfiConverterTypeFFINetworkingRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: FfiNetworkingResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeFFINetworkingResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFFINetworkingError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeNetworkAntenna.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NetworkAntenna: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNetworkAntenna() {
    uniffi_crypto_service_fn_init_callback_vtable_networkantenna(&UniffiCallbackInterfaceNetworkAntenna.vtable)
}

public struct FfiConverterTypeNetworkAntenna: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NetworkAntenna>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkAntenna

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkAntenna {
        return NetworkAntennaImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkAntenna) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkAntenna {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkAntenna, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNetworkAntenna_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkAntenna {
    return try FfiConverterTypeNetworkAntenna.lift(pointer)
}

public func FfiConverterTypeNetworkAntenna_lower(_ value: NetworkAntenna) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkAntenna.lower(value)
}

public struct AggregatedCoinInformation {
    public let name: String
    public let symbol: String
    public let rank: Int64
    public let rate: Double
    public let color: String
    public let png64: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, symbol: String, rank: Int64, rate: Double, color: String, png64: String) {
        self.name = name
        self.symbol = symbol
        self.rank = rank
        self.rate = rate
        self.color = color
        self.png64 = png64
    }
}

extension AggregatedCoinInformation: Equatable, Hashable {
    public static func == (lhs: AggregatedCoinInformation, rhs: AggregatedCoinInformation) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.rank != rhs.rank {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.png64 != rhs.png64 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(symbol)
        hasher.combine(rank)
        hasher.combine(rate)
        hasher.combine(color)
        hasher.combine(png64)
    }
}

public struct FfiConverterTypeAggregatedCoinInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AggregatedCoinInformation {
        return
            try AggregatedCoinInformation(
                name: FfiConverterString.read(from: &buf),
                symbol: FfiConverterString.read(from: &buf),
                rank: FfiConverterInt64.read(from: &buf),
                rate: FfiConverterDouble.read(from: &buf),
                color: FfiConverterString.read(from: &buf),
                png64: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: AggregatedCoinInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterInt64.write(value.rank, into: &buf)
        FfiConverterDouble.write(value.rate, into: &buf)
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterString.write(value.png64, into: &buf)
    }
}

public func FfiConverterTypeAggregatedCoinInformation_lift(_ buf: RustBuffer) throws -> AggregatedCoinInformation {
    return try FfiConverterTypeAggregatedCoinInformation.lift(buf)
}

public func FfiConverterTypeAggregatedCoinInformation_lower(_ value: AggregatedCoinInformation) -> RustBuffer {
    return FfiConverterTypeAggregatedCoinInformation.lower(value)
}

public struct Coin {
    public let code: String
    public let rate: Double
    public let volume: Int64
    public let cap: Int64?
    public let delta: Delta

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: String, rate: Double, volume: Int64, cap: Int64?, delta: Delta) {
        self.code = code
        self.rate = rate
        self.volume = volume
        self.cap = cap
        self.delta = delta
    }
}

extension Coin: Equatable, Hashable {
    public static func == (lhs: Coin, rhs: Coin) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        if lhs.cap != rhs.cap {
            return false
        }
        if lhs.delta != rhs.delta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(rate)
        hasher.combine(volume)
        hasher.combine(cap)
        hasher.combine(delta)
    }
}

public struct FfiConverterTypeCoin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Coin {
        return
            try Coin(
                code: FfiConverterString.read(from: &buf),
                rate: FfiConverterDouble.read(from: &buf),
                volume: FfiConverterInt64.read(from: &buf),
                cap: FfiConverterOptionInt64.read(from: &buf),
                delta: FfiConverterTypeDelta.read(from: &buf)
            )
    }

    public static func write(_ value: Coin, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterDouble.write(value.rate, into: &buf)
        FfiConverterInt64.write(value.volume, into: &buf)
        FfiConverterOptionInt64.write(value.cap, into: &buf)
        FfiConverterTypeDelta.write(value.delta, into: &buf)
    }
}

public func FfiConverterTypeCoin_lift(_ buf: RustBuffer) throws -> Coin {
    return try FfiConverterTypeCoin.lift(buf)
}

public func FfiConverterTypeCoin_lower(_ value: Coin) -> RustBuffer {
    return FfiConverterTypeCoin.lower(value)
}

public struct CoinHistoryRequest {
    public let currency: String
    public let code: String
    public let start: UInt64
    public let end: UInt64
    public let meta: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(currency: String, code: String, start: UInt64, end: UInt64, meta: Bool) {
        self.currency = currency
        self.code = code
        self.start = start
        self.end = end
        self.meta = meta
    }
}

extension CoinHistoryRequest: Equatable, Hashable {
    public static func == (lhs: CoinHistoryRequest, rhs: CoinHistoryRequest) -> Bool {
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.start != rhs.start {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currency)
        hasher.combine(code)
        hasher.combine(start)
        hasher.combine(end)
        hasher.combine(meta)
    }
}

public struct FfiConverterTypeCoinHistoryRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinHistoryRequest {
        return
            try CoinHistoryRequest(
                currency: FfiConverterString.read(from: &buf),
                code: FfiConverterString.read(from: &buf),
                start: FfiConverterUInt64.read(from: &buf),
                end: FfiConverterUInt64.read(from: &buf),
                meta: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: CoinHistoryRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterUInt64.write(value.start, into: &buf)
        FfiConverterUInt64.write(value.end, into: &buf)
        FfiConverterBool.write(value.meta, into: &buf)
    }
}

public func FfiConverterTypeCoinHistoryRequest_lift(_ buf: RustBuffer) throws -> CoinHistoryRequest {
    return try FfiConverterTypeCoinHistoryRequest.lift(buf)
}

public func FfiConverterTypeCoinHistoryRequest_lower(_ value: CoinHistoryRequest) -> RustBuffer {
    return FfiConverterTypeCoinHistoryRequest.lower(value)
}

public struct CoinMeta {
    public let code: String?
    public let name: String
    public let symbol: String?
    public let rank: Int64
    public let age: Int64
    public let color: String
    public let png32: String
    public let png64: String
    public let webp32: String
    public let webp64: String
    public let allTimeHighUsd: Double
    public let links: Links
    public let delta: Delta?
    public let history: [History]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: String?, name: String, symbol: String?, rank: Int64, age: Int64, color: String, png32: String, png64: String, webp32: String, webp64: String, allTimeHighUsd: Double, links: Links, delta: Delta?, history: [History]?) {
        self.code = code
        self.name = name
        self.symbol = symbol
        self.rank = rank
        self.age = age
        self.color = color
        self.png32 = png32
        self.png64 = png64
        self.webp32 = webp32
        self.webp64 = webp64
        self.allTimeHighUsd = allTimeHighUsd
        self.links = links
        self.delta = delta
        self.history = history
    }
}

extension CoinMeta: Equatable, Hashable {
    public static func == (lhs: CoinMeta, rhs: CoinMeta) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.rank != rhs.rank {
            return false
        }
        if lhs.age != rhs.age {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.png32 != rhs.png32 {
            return false
        }
        if lhs.png64 != rhs.png64 {
            return false
        }
        if lhs.webp32 != rhs.webp32 {
            return false
        }
        if lhs.webp64 != rhs.webp64 {
            return false
        }
        if lhs.allTimeHighUsd != rhs.allTimeHighUsd {
            return false
        }
        if lhs.links != rhs.links {
            return false
        }
        if lhs.delta != rhs.delta {
            return false
        }
        if lhs.history != rhs.history {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(name)
        hasher.combine(symbol)
        hasher.combine(rank)
        hasher.combine(age)
        hasher.combine(color)
        hasher.combine(png32)
        hasher.combine(png64)
        hasher.combine(webp32)
        hasher.combine(webp64)
        hasher.combine(allTimeHighUsd)
        hasher.combine(links)
        hasher.combine(delta)
        hasher.combine(history)
    }
}

public struct FfiConverterTypeCoinMeta: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinMeta {
        return
            try CoinMeta(
                code: FfiConverterOptionString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                symbol: FfiConverterOptionString.read(from: &buf),
                rank: FfiConverterInt64.read(from: &buf),
                age: FfiConverterInt64.read(from: &buf),
                color: FfiConverterString.read(from: &buf),
                png32: FfiConverterString.read(from: &buf),
                png64: FfiConverterString.read(from: &buf),
                webp32: FfiConverterString.read(from: &buf),
                webp64: FfiConverterString.read(from: &buf),
                allTimeHighUsd: FfiConverterDouble.read(from: &buf),
                links: FfiConverterTypeLinks.read(from: &buf),
                delta: FfiConverterOptionTypeDelta.read(from: &buf),
                history: FfiConverterOptionSequenceTypeHistory.read(from: &buf)
            )
    }

    public static func write(_ value: CoinMeta, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.code, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.symbol, into: &buf)
        FfiConverterInt64.write(value.rank, into: &buf)
        FfiConverterInt64.write(value.age, into: &buf)
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterString.write(value.png32, into: &buf)
        FfiConverterString.write(value.png64, into: &buf)
        FfiConverterString.write(value.webp32, into: &buf)
        FfiConverterString.write(value.webp64, into: &buf)
        FfiConverterDouble.write(value.allTimeHighUsd, into: &buf)
        FfiConverterTypeLinks.write(value.links, into: &buf)
        FfiConverterOptionTypeDelta.write(value.delta, into: &buf)
        FfiConverterOptionSequenceTypeHistory.write(value.history, into: &buf)
    }
}

public func FfiConverterTypeCoinMeta_lift(_ buf: RustBuffer) throws -> CoinMeta {
    return try FfiConverterTypeCoinMeta.lift(buf)
}

public func FfiConverterTypeCoinMeta_lower(_ value: CoinMeta) -> RustBuffer {
    return FfiConverterTypeCoinMeta.lower(value)
}

public struct CoinMetaRequest {
    public let currency: String
    public let code: String
    public let meta: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(currency: String, code: String, meta: Bool) {
        self.currency = currency
        self.code = code
        self.meta = meta
    }
}

extension CoinMetaRequest: Equatable, Hashable {
    public static func == (lhs: CoinMetaRequest, rhs: CoinMetaRequest) -> Bool {
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currency)
        hasher.combine(code)
        hasher.combine(meta)
    }
}

public struct FfiConverterTypeCoinMetaRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinMetaRequest {
        return
            try CoinMetaRequest(
                currency: FfiConverterString.read(from: &buf),
                code: FfiConverterString.read(from: &buf),
                meta: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: CoinMetaRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterBool.write(value.meta, into: &buf)
    }
}

public func FfiConverterTypeCoinMetaRequest_lift(_ buf: RustBuffer) throws -> CoinMetaRequest {
    return try FfiConverterTypeCoinMetaRequest.lift(buf)
}

public func FfiConverterTypeCoinMetaRequest_lower(_ value: CoinMetaRequest) -> RustBuffer {
    return FfiConverterTypeCoinMetaRequest.lower(value)
}

public struct Delta {
    public let hour: Double
    public let day: Double
    public let week: Double
    public let month: Double
    public let quarter: Double
    public let year: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hour: Double, day: Double, week: Double, month: Double, quarter: Double, year: Double) {
        self.hour = hour
        self.day = day
        self.week = week
        self.month = month
        self.quarter = quarter
        self.year = year
    }
}

extension Delta: Equatable, Hashable {
    public static func == (lhs: Delta, rhs: Delta) -> Bool {
        if lhs.hour != rhs.hour {
            return false
        }
        if lhs.day != rhs.day {
            return false
        }
        if lhs.week != rhs.week {
            return false
        }
        if lhs.month != rhs.month {
            return false
        }
        if lhs.quarter != rhs.quarter {
            return false
        }
        if lhs.year != rhs.year {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hour)
        hasher.combine(day)
        hasher.combine(week)
        hasher.combine(month)
        hasher.combine(quarter)
        hasher.combine(year)
    }
}

public struct FfiConverterTypeDelta: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Delta {
        return
            try Delta(
                hour: FfiConverterDouble.read(from: &buf),
                day: FfiConverterDouble.read(from: &buf),
                week: FfiConverterDouble.read(from: &buf),
                month: FfiConverterDouble.read(from: &buf),
                quarter: FfiConverterDouble.read(from: &buf),
                year: FfiConverterDouble.read(from: &buf)
            )
    }

    public static func write(_ value: Delta, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.hour, into: &buf)
        FfiConverterDouble.write(value.day, into: &buf)
        FfiConverterDouble.write(value.week, into: &buf)
        FfiConverterDouble.write(value.month, into: &buf)
        FfiConverterDouble.write(value.quarter, into: &buf)
        FfiConverterDouble.write(value.year, into: &buf)
    }
}

public func FfiConverterTypeDelta_lift(_ buf: RustBuffer) throws -> Delta {
    return try FfiConverterTypeDelta.lift(buf)
}

public func FfiConverterTypeDelta_lower(_ value: Delta) -> RustBuffer {
    return FfiConverterTypeDelta.lower(value)
}

public struct FfiNetworkingRequest {
    public let url: String
    public let method: String
    public let headers: [String: String]
    public let body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, method: String, headers: [String: String], body: Data) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}

extension FfiNetworkingRequest: Equatable, Hashable {
    public static func == (lhs: FfiNetworkingRequest, rhs: FfiNetworkingRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFFINetworkingRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiNetworkingRequest {
        return
            try FfiNetworkingRequest(
                url: FfiConverterString.read(from: &buf),
                method: FfiConverterString.read(from: &buf),
                headers: FfiConverterDictionaryStringString.read(from: &buf),
                body: FfiConverterData.read(from: &buf)
            )
    }

    public static func write(_ value: FfiNetworkingRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFFINetworkingRequest_lift(_ buf: RustBuffer) throws -> FfiNetworkingRequest {
    return try FfiConverterTypeFFINetworkingRequest.lift(buf)
}

public func FfiConverterTypeFFINetworkingRequest_lower(_ value: FfiNetworkingRequest) -> RustBuffer {
    return FfiConverterTypeFFINetworkingRequest.lower(value)
}

public struct FfiNetworkingResponse {
    public let statusCode: UInt16
    /**
     * Can be empty.
     */
    public let body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16,
                /**
                    * Can be empty.
                    */ body: Data)
    {
        self.statusCode = statusCode
        self.body = body
    }
}

extension FfiNetworkingResponse: Equatable, Hashable {
    public static func == (lhs: FfiNetworkingResponse, rhs: FfiNetworkingResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFFINetworkingResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiNetworkingResponse {
        return
            try FfiNetworkingResponse(
                statusCode: FfiConverterUInt16.read(from: &buf),
                body: FfiConverterData.read(from: &buf)
            )
    }

    public static func write(_ value: FfiNetworkingResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFFINetworkingResponse_lift(_ buf: RustBuffer) throws -> FfiNetworkingResponse {
    return try FfiConverterTypeFFINetworkingResponse.lift(buf)
}

public func FfiConverterTypeFFINetworkingResponse_lower(_ value: FfiNetworkingResponse) -> RustBuffer {
    return FfiConverterTypeFFINetworkingResponse.lower(value)
}

public struct History {
    public let date: Int64
    public let rate: Double
    public let volume: Int64
    public let cap: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(date: Int64, rate: Double, volume: Int64, cap: Int64) {
        self.date = date
        self.rate = rate
        self.volume = volume
        self.cap = cap
    }
}

extension History: Equatable, Hashable {
    public static func == (lhs: History, rhs: History) -> Bool {
        if lhs.date != rhs.date {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        if lhs.cap != rhs.cap {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(date)
        hasher.combine(rate)
        hasher.combine(volume)
        hasher.combine(cap)
    }
}

public struct FfiConverterTypeHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> History {
        return
            try History(
                date: FfiConverterInt64.read(from: &buf),
                rate: FfiConverterDouble.read(from: &buf),
                volume: FfiConverterInt64.read(from: &buf),
                cap: FfiConverterInt64.read(from: &buf)
            )
    }

    public static func write(_ value: History, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.date, into: &buf)
        FfiConverterDouble.write(value.rate, into: &buf)
        FfiConverterInt64.write(value.volume, into: &buf)
        FfiConverterInt64.write(value.cap, into: &buf)
    }
}

public func FfiConverterTypeHistory_lift(_ buf: RustBuffer) throws -> History {
    return try FfiConverterTypeHistory.lift(buf)
}

public func FfiConverterTypeHistory_lower(_ value: History) -> RustBuffer {
    return FfiConverterTypeHistory.lower(value)
}

public struct Links {
    public let website: String?
    public let whitepaper: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(website: String?, whitepaper: String?) {
        self.website = website
        self.whitepaper = whitepaper
    }
}

extension Links: Equatable, Hashable {
    public static func == (lhs: Links, rhs: Links) -> Bool {
        if lhs.website != rhs.website {
            return false
        }
        if lhs.whitepaper != rhs.whitepaper {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(website)
        hasher.combine(whitepaper)
    }
}

public struct FfiConverterTypeLinks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Links {
        return
            try Links(
                website: FfiConverterOptionString.read(from: &buf),
                whitepaper: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: Links, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.website, into: &buf)
        FfiConverterOptionString.write(value.whitepaper, into: &buf)
    }
}

public func FfiConverterTypeLinks_lift(_ buf: RustBuffer) throws -> Links {
    return try FfiConverterTypeLinks.lift(buf)
}

public func FfiConverterTypeLinks_lower(_ value: Links) -> RustBuffer {
    return FfiConverterTypeLinks.lower(value)
}

public struct ListOfCoinsRequest {
    public let currency: String
    public let sort: Sort
    public let order: String
    public let offset: UInt8
    public let limit: UInt32
    public let meta: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(currency: String, sort: Sort, order: String, offset: UInt8, limit: UInt32, meta: Bool) {
        self.currency = currency
        self.sort = sort
        self.order = order
        self.offset = offset
        self.limit = limit
        self.meta = meta
    }
}

extension ListOfCoinsRequest: Equatable, Hashable {
    public static func == (lhs: ListOfCoinsRequest, rhs: ListOfCoinsRequest) -> Bool {
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.sort != rhs.sort {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currency)
        hasher.combine(sort)
        hasher.combine(order)
        hasher.combine(offset)
        hasher.combine(limit)
        hasher.combine(meta)
    }
}

public struct FfiConverterTypeListOfCoinsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListOfCoinsRequest {
        return
            try ListOfCoinsRequest(
                currency: FfiConverterString.read(from: &buf),
                sort: FfiConverterTypeSort.read(from: &buf),
                order: FfiConverterString.read(from: &buf),
                offset: FfiConverterUInt8.read(from: &buf),
                limit: FfiConverterUInt32.read(from: &buf),
                meta: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: ListOfCoinsRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterTypeSort.write(value.sort, into: &buf)
        FfiConverterString.write(value.order, into: &buf)
        FfiConverterUInt8.write(value.offset, into: &buf)
        FfiConverterUInt32.write(value.limit, into: &buf)
        FfiConverterBool.write(value.meta, into: &buf)
    }
}

public func FfiConverterTypeListOfCoinsRequest_lift(_ buf: RustBuffer) throws -> ListOfCoinsRequest {
    return try FfiConverterTypeListOfCoinsRequest.lift(buf)
}

public func FfiConverterTypeListOfCoinsRequest_lower(_ value: ListOfCoinsRequest) -> RustBuffer {
    return FfiConverterTypeListOfCoinsRequest.lower(value)
}

public struct MostActivelyTraded {
    public let ticker: String
    public let price: String
    public let changeAmount: String
    public let changePercentage: String
    public let volume: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ticker: String, price: String, changeAmount: String, changePercentage: String, volume: String) {
        self.ticker = ticker
        self.price = price
        self.changeAmount = changeAmount
        self.changePercentage = changePercentage
        self.volume = volume
    }
}

extension MostActivelyTraded: Equatable, Hashable {
    public static func == (lhs: MostActivelyTraded, rhs: MostActivelyTraded) -> Bool {
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        if lhs.changeAmount != rhs.changeAmount {
            return false
        }
        if lhs.changePercentage != rhs.changePercentage {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ticker)
        hasher.combine(price)
        hasher.combine(changeAmount)
        hasher.combine(changePercentage)
        hasher.combine(volume)
    }
}

public struct FfiConverterTypeMostActivelyTraded: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MostActivelyTraded {
        return
            try MostActivelyTraded(
                ticker: FfiConverterString.read(from: &buf),
                price: FfiConverterString.read(from: &buf),
                changeAmount: FfiConverterString.read(from: &buf),
                changePercentage: FfiConverterString.read(from: &buf),
                volume: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: MostActivelyTraded, into buf: inout [UInt8]) {
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterString.write(value.price, into: &buf)
        FfiConverterString.write(value.changeAmount, into: &buf)
        FfiConverterString.write(value.changePercentage, into: &buf)
        FfiConverterString.write(value.volume, into: &buf)
    }
}

public func FfiConverterTypeMostActivelyTraded_lift(_ buf: RustBuffer) throws -> MostActivelyTraded {
    return try FfiConverterTypeMostActivelyTraded.lift(buf)
}

public func FfiConverterTypeMostActivelyTraded_lower(_ value: MostActivelyTraded) -> RustBuffer {
    return FfiConverterTypeMostActivelyTraded.lower(value)
}

public struct OrderBook {
    public let asks: [[String]]
    public let bids: [[String]]
    public let lastUpdateId: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(asks: [[String]], bids: [[String]], lastUpdateId: UInt64) {
        self.asks = asks
        self.bids = bids
        self.lastUpdateId = lastUpdateId
    }
}

extension OrderBook: Equatable, Hashable {
    public static func == (lhs: OrderBook, rhs: OrderBook) -> Bool {
        if lhs.asks != rhs.asks {
            return false
        }
        if lhs.bids != rhs.bids {
            return false
        }
        if lhs.lastUpdateId != rhs.lastUpdateId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(asks)
        hasher.combine(bids)
        hasher.combine(lastUpdateId)
    }
}

public struct FfiConverterTypeOrderBook: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrderBook {
        return
            try OrderBook(
                asks: FfiConverterSequenceSequenceString.read(from: &buf),
                bids: FfiConverterSequenceSequenceString.read(from: &buf),
                lastUpdateId: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: OrderBook, into buf: inout [UInt8]) {
        FfiConverterSequenceSequenceString.write(value.asks, into: &buf)
        FfiConverterSequenceSequenceString.write(value.bids, into: &buf)
        FfiConverterUInt64.write(value.lastUpdateId, into: &buf)
    }
}

public func FfiConverterTypeOrderBook_lift(_ buf: RustBuffer) throws -> OrderBook {
    return try FfiConverterTypeOrderBook.lift(buf)
}

public func FfiConverterTypeOrderBook_lower(_ value: OrderBook) -> RustBuffer {
    return FfiConverterTypeOrderBook.lower(value)
}

public struct Params {
    public let symbol: String
    public let limit: UInt16?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(symbol: String, limit: UInt16?) {
        self.symbol = symbol
        self.limit = limit
    }
}

extension Params: Equatable, Hashable {
    public static func == (lhs: Params, rhs: Params) -> Bool {
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(symbol)
        hasher.combine(limit)
    }
}

public struct FfiConverterTypeParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Params {
        return
            try Params(
                symbol: FfiConverterString.read(from: &buf),
                limit: FfiConverterOptionUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: Params, into buf: inout [UInt8]) {
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterOptionUInt16.write(value.limit, into: &buf)
    }
}

public func FfiConverterTypeParams_lift(_ buf: RustBuffer) throws -> Params {
    return try FfiConverterTypeParams.lift(buf)
}

public func FfiConverterTypeParams_lower(_ value: Params) -> RustBuffer {
    return FfiConverterTypeParams.lower(value)
}

public struct RecentTradesResponse {
    public let id: UInt64
    public let price: String
    public let quantity: String
    public let quoteQuantity: String
    public let time: UInt64
    public let isBuyerMaker: Bool
    public let isBestMatch: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64, price: String, quantity: String, quoteQuantity: String, time: UInt64, isBuyerMaker: Bool, isBestMatch: Bool) {
        self.id = id
        self.price = price
        self.quantity = quantity
        self.quoteQuantity = quoteQuantity
        self.time = time
        self.isBuyerMaker = isBuyerMaker
        self.isBestMatch = isBestMatch
    }
}

extension RecentTradesResponse: Equatable, Hashable {
    public static func == (lhs: RecentTradesResponse, rhs: RecentTradesResponse) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        if lhs.quoteQuantity != rhs.quoteQuantity {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.isBuyerMaker != rhs.isBuyerMaker {
            return false
        }
        if lhs.isBestMatch != rhs.isBestMatch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(price)
        hasher.combine(quantity)
        hasher.combine(quoteQuantity)
        hasher.combine(time)
        hasher.combine(isBuyerMaker)
        hasher.combine(isBestMatch)
    }
}

public struct FfiConverterTypeRecentTradesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecentTradesResponse {
        return
            try RecentTradesResponse(
                id: FfiConverterUInt64.read(from: &buf),
                price: FfiConverterString.read(from: &buf),
                quantity: FfiConverterString.read(from: &buf),
                quoteQuantity: FfiConverterString.read(from: &buf),
                time: FfiConverterUInt64.read(from: &buf),
                isBuyerMaker: FfiConverterBool.read(from: &buf),
                isBestMatch: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: RecentTradesResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterString.write(value.price, into: &buf)
        FfiConverterString.write(value.quantity, into: &buf)
        FfiConverterString.write(value.quoteQuantity, into: &buf)
        FfiConverterUInt64.write(value.time, into: &buf)
        FfiConverterBool.write(value.isBuyerMaker, into: &buf)
        FfiConverterBool.write(value.isBestMatch, into: &buf)
    }
}

public func FfiConverterTypeRecentTradesResponse_lift(_ buf: RustBuffer) throws -> RecentTradesResponse {
    return try FfiConverterTypeRecentTradesResponse.lift(buf)
}

public func FfiConverterTypeRecentTradesResponse_lower(_ value: RecentTradesResponse) -> RustBuffer {
    return FfiConverterTypeRecentTradesResponse.lower(value)
}

public struct TopAndBottomTrades {
    public let metadata: String
    public let lastUpdated: String
    public let topGainers: [MostActivelyTraded]
    public let topLosers: [MostActivelyTraded]
    public let mostActivelyTraded: [MostActivelyTraded]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(metadata: String, lastUpdated: String, topGainers: [MostActivelyTraded], topLosers: [MostActivelyTraded], mostActivelyTraded: [MostActivelyTraded]) {
        self.metadata = metadata
        self.lastUpdated = lastUpdated
        self.topGainers = topGainers
        self.topLosers = topLosers
        self.mostActivelyTraded = mostActivelyTraded
    }
}

extension TopAndBottomTrades: Equatable, Hashable {
    public static func == (lhs: TopAndBottomTrades, rhs: TopAndBottomTrades) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.lastUpdated != rhs.lastUpdated {
            return false
        }
        if lhs.topGainers != rhs.topGainers {
            return false
        }
        if lhs.topLosers != rhs.topLosers {
            return false
        }
        if lhs.mostActivelyTraded != rhs.mostActivelyTraded {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(lastUpdated)
        hasher.combine(topGainers)
        hasher.combine(topLosers)
        hasher.combine(mostActivelyTraded)
    }
}

public struct FfiConverterTypeTopAndBottomTrades: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopAndBottomTrades {
        return
            try TopAndBottomTrades(
                metadata: FfiConverterString.read(from: &buf),
                lastUpdated: FfiConverterString.read(from: &buf),
                topGainers: FfiConverterSequenceTypeMostActivelyTraded.read(from: &buf),
                topLosers: FfiConverterSequenceTypeMostActivelyTraded.read(from: &buf),
                mostActivelyTraded: FfiConverterSequenceTypeMostActivelyTraded.read(from: &buf)
            )
    }

    public static func write(_ value: TopAndBottomTrades, into buf: inout [UInt8]) {
        FfiConverterString.write(value.metadata, into: &buf)
        FfiConverterString.write(value.lastUpdated, into: &buf)
        FfiConverterSequenceTypeMostActivelyTraded.write(value.topGainers, into: &buf)
        FfiConverterSequenceTypeMostActivelyTraded.write(value.topLosers, into: &buf)
        FfiConverterSequenceTypeMostActivelyTraded.write(value.mostActivelyTraded, into: &buf)
    }
}

public func FfiConverterTypeTopAndBottomTrades_lift(_ buf: RustBuffer) throws -> TopAndBottomTrades {
    return try FfiConverterTypeTopAndBottomTrades.lift(buf)
}

public func FfiConverterTypeTopAndBottomTrades_lower(_ value: TopAndBottomTrades) -> RustBuffer {
    return FfiConverterTypeTopAndBottomTrades.lower(value)
}

public enum FfiBridgeError {
    case FromRust(error: RustSideError
    )
    case FromFfi(error: FfiSideError
    )
}

public struct FfiConverterTypeFFIBridgeError: FfiConverterRustBuffer {
    typealias SwiftType = FfiBridgeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBridgeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .FromRust(
                error: FfiConverterTypeRustSideError.read(from: &buf)
            )
        case 2: return try .FromFfi(
                error: FfiConverterTypeFFISideError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiBridgeError, into buf: inout [UInt8]) {
        switch value {
        case let .FromRust(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRustSideError.write(error, into: &buf)

        case let .FromFfi(error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFFISideError.write(error, into: &buf)
        }
    }
}

extension FfiBridgeError: Equatable, Hashable {}

extension FfiBridgeError: Error {}

public enum FfiNetworkingError {
    case FailedToCreateUrlFrom(string: String
    )
    case RequestFailed(statusCode: UInt16?, urlSessionUnderlyingError: String?, errorMessageFromGateway: String?)
}

public struct FfiConverterTypeFFINetworkingError: FfiConverterRustBuffer {
    typealias SwiftType = FfiNetworkingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiNetworkingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .FailedToCreateUrlFrom(
                string: FfiConverterString.read(from: &buf)
            )
        case 2: return try .RequestFailed(
                statusCode: FfiConverterOptionUInt16.read(from: &buf),
                urlSessionUnderlyingError: FfiConverterOptionString.read(from: &buf),
                errorMessageFromGateway: FfiConverterOptionString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiNetworkingError, into buf: inout [UInt8]) {
        switch value {
        case let .FailedToCreateUrlFrom(string):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(string, into: &buf)

        case let .RequestFailed(statusCode, urlSessionUnderlyingError, errorMessageFromGateway):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterOptionString.write(urlSessionUnderlyingError, into: &buf)
            FfiConverterOptionString.write(errorMessageFromGateway, into: &buf)
        }
    }
}

extension FfiNetworkingError: Equatable, Hashable {}

extension FfiNetworkingError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiSideError {
    case networking(error: FfiNetworkingError
    )
}

public struct FfiConverterTypeFFISideError: FfiConverterRustBuffer {
    typealias SwiftType = FfiSideError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSideError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .networking(error: FfiConverterTypeFFINetworkingError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSideError, into buf: inout [UInt8]) {
        switch value {
        case let .networking(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFFINetworkingError.write(error, into: &buf)
        }
    }
}

public func FfiConverterTypeFFISideError_lift(_ buf: RustBuffer) throws -> FfiSideError {
    return try FfiConverterTypeFFISideError.lift(buf)
}

public func FfiConverterTypeFFISideError_lower(_ value: FfiSideError) -> RustBuffer {
    return FfiConverterTypeFFISideError.lower(value)
}

extension FfiSideError: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RustSideError {
    case noResponseCode
    case badResponseCode
    case unableJsonDeserializeHttpResponseBodyIntoTypeName(typeName: String
    )
    case noXrdBalanceFound
    case failedToReceiveResponseFromSwift
    case failedToPropagateResultFromFfiOperationBackToDispatcher
    case responseBodyWasNil
    case wrongFfiOperationOkExpectedFfiNetworkingResponse
}

public struct FfiConverterTypeRustSideError: FfiConverterRustBuffer {
    typealias SwiftType = RustSideError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustSideError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .noResponseCode

        case 2: return .badResponseCode

        case 3: return try .unableJsonDeserializeHttpResponseBodyIntoTypeName(typeName: FfiConverterString.read(from: &buf)
            )

        case 4: return .noXrdBalanceFound

        case 5: return .failedToReceiveResponseFromSwift

        case 6: return .failedToPropagateResultFromFfiOperationBackToDispatcher

        case 7: return .responseBodyWasNil

        case 8: return .wrongFfiOperationOkExpectedFfiNetworkingResponse

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RustSideError, into buf: inout [UInt8]) {
        switch value {
        case .noResponseCode:
            writeInt(&buf, Int32(1))

        case .badResponseCode:
            writeInt(&buf, Int32(2))

        case let .unableJsonDeserializeHttpResponseBodyIntoTypeName(typeName):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(typeName, into: &buf)

        case .noXrdBalanceFound:
            writeInt(&buf, Int32(4))

        case .failedToReceiveResponseFromSwift:
            writeInt(&buf, Int32(5))

        case .failedToPropagateResultFromFfiOperationBackToDispatcher:
            writeInt(&buf, Int32(6))

        case .responseBodyWasNil:
            writeInt(&buf, Int32(7))

        case .wrongFfiOperationOkExpectedFfiNetworkingResponse:
            writeInt(&buf, Int32(8))
        }
    }
}

public func FfiConverterTypeRustSideError_lift(_ buf: RustBuffer) throws -> RustSideError {
    return try FfiConverterTypeRustSideError.lift(buf)
}

public func FfiConverterTypeRustSideError_lower(_ value: RustSideError) -> RustBuffer {
    return FfiConverterTypeRustSideError.lower(value)
}

extension RustSideError: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Sort {
    case rank
    case price
    case volume
    case code
    case name
    case age
}

public struct FfiConverterTypeSort: FfiConverterRustBuffer {
    typealias SwiftType = Sort

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sort {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .rank

        case 2: return .price

        case 3: return .volume

        case 4: return .code

        case 5: return .name

        case 6: return .age

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Sort, into buf: inout [UInt8]) {
        switch value {
        case .rank:
            writeInt(&buf, Int32(1))

        case .price:
            writeInt(&buf, Int32(2))

        case .volume:
            writeInt(&buf, Int32(3))

        case .code:
            writeInt(&buf, Int32(4))

        case .name:
            writeInt(&buf, Int32(5))

        case .age:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeSort_lift(_ buf: RustBuffer) throws -> Sort {
    return try FfiConverterTypeSort.lift(buf)
}

public func FfiConverterTypeSort_lower(_ value: Sort) -> RustBuffer {
    return FfiConverterTypeSort.lower(value)
}

extension Sort: Equatable, Hashable {}

private struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDelta: FfiConverterRustBuffer {
    typealias SwiftType = Delta?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDelta.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDelta.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeHistory: FfiConverterRustBuffer {
    typealias SwiftType = [History]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeHistory.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeHistory.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeCoin: FfiConverterRustBuffer {
    typealias SwiftType = [Coin]

    public static func write(_ value: [Coin], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCoin.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Coin] {
        let len: Int32 = try readInt(&buf)
        var seq = [Coin]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeCoin.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHistory: FfiConverterRustBuffer {
    typealias SwiftType = [History]

    public static func write(_ value: [History], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHistory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [History] {
        let len: Int32 = try readInt(&buf)
        var seq = [History]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHistory.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeMostActivelyTraded: FfiConverterRustBuffer {
    typealias SwiftType = [MostActivelyTraded]

    public static func write(_ value: [MostActivelyTraded], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMostActivelyTraded.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MostActivelyTraded] {
        let len: Int32 = try readInt(&buf)
        var seq = [MostActivelyTraded]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeMostActivelyTraded.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void,
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
private var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountCryptoService() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_crypto_service_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_crypto_service_checksum_method_gateway_get_list_of_agg_coins() != 25726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_crypto_service_checksum_method_networkantenna_make_request() != 5199 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_crypto_service_checksum_constructor_gateway_new() != 54231 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitNetworkAntenna()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
